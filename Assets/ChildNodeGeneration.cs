using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using MapAssets;
using System;
using MapNode;

namespace MapChildNodeGen
{
    public class ChildNodeGen : MonoBehaviour
    {
        private int childNum;   // number of child nodes for each naiborhoodSize
        private int naiborhoodSize; // how many layes of child nodes the initial parent node should have 
                                    // The actual amount  of nodes generated by the running object is the multiplication between the two variables

        private Node[,] childNodes; // Two dimentional array holding the child nodes

        // Directions used to position Nodes by taking into consideration the parent node position in the 2D array (Child Nodes)
        private Vector2[] validDirections = {new Vector2(1, 0), new Vector2(-1, 0), new Vector2(0, 1), new Vector2(0, -1),
                                new Vector2(1, 1), new Vector2(-1, 1), new Vector2(1, -1), new Vector2(-1, -1)};
        private float offset;

        // The coordinates in the 2D array, which is also the running Node(Parent) object 
        Vector2 centerNodeCord;

        // Initialize node
        public void Initialize(int maxChildNum, int maxGridNum)
        {
            offset = 5;

            naiborhoodSize = UnityEngine.Random.Range(2, maxGridNum);
            childNodes = new Node[(int)(naiborhoodSize), (int)(naiborhoodSize)];

            childNodes[childNodes.GetLength(0) / 2, childNodes.GetLength(1) / 2] = this.gameObject.GetComponent<Node>();
            childNum = UnityEngine.Random.Range(1, maxChildNum);
        }

        // Error check
        bool Error()
        {
            if (!GetComponent<Node>())
            {
                Debug.Log("Component Node is missing");
                return true;
            }
            return false;
        }

        // Sets building number
        public void SetBuildingNum(int buildingNum)
        {
            this.childNum = buildingNum;
        }

        // Generates Child Nodes using a type
        public void GenerateChildNodes(Node.Type type)
        {
            for (int x = 0; x < childNodes.GetLength(0); x++)
            {
                for (int y = 0; y < childNodes.GetLength(1); y++)
                {
                    GameObject nodeObj = new GameObject();
                    nodeObj.name = "Child Node";

                    nodeObj.AddComponent<MeshFilter>();
                    nodeObj.AddComponent<MeshRenderer>();
                    nodeObj.AddComponent<ChildNodeGen>();

                    Node node = nodeObj.AddComponent<Node>();
                    node.Initialize();

                    childNodes[x, y] = node;
                }
            }

            childNodes[(int)childNodes.GetLength(0) / 2, (int)childNodes.GetLength(1) / 2] = this.gameObject.GetComponent<Node>();
            childNodes[(int)childNodes.GetLength(0) / 2, (int)childNodes.GetLength(1) / 2].type = type;

            centerNodeCord = new Vector2(childNodes.GetLength(0) / 2, childNodes.GetLength(1) / 2);
        }

        public List<Vector2> GeneratePoints(Node.Type type)
        {
            Node centerNode = this.gameObject.GetComponent<Node>();
            float offset = 20;

            int randomIndex;
            Node randomNode = new Node();
            Vector2 nodeCords = new Vector2();
            List<Vector2> generationPoints = new List<Vector2>();

            for (int i = 0; i < naiborhoodSize / 2; i++)    //for (int i = 0; i < naiborhoodSize / 2; i++) thats the correct one!
            {
                List<Vector2> currentNodesCord = new List<Vector2>();

                for (int x = 0; x < validDirections.Length; x++)
                {
                    currentNodesCord.Add(centerNodeCord + validDirections[x] + new Vector2(validDirections[x].x * i, validDirections[x].y * i));
                }

                // spawn naibor buildings end condition defines the amount
                for (int a = 0; a < childNum; a++)
                {
                    do
                    {
                        randomIndex = UnityEngine.Random.Range(0, currentNodesCord.Count);
                        nodeCords = new Vector2((int)currentNodesCord[randomIndex].x, (int)currentNodesCord[randomIndex].y);

                        if ((int)nodeCords.x < childNodes.GetLength(0) && (int)nodeCords.y < childNodes.GetLength(1))
                            randomNode = childNodes[(int)nodeCords.x, (int)nodeCords.y];
                        else
                            randomNode = null;
                    }
                    while (randomNode == null || randomNode.type == type);

                    generationPoints.Add(nodeCords);
                }
            }
            return generationPoints;
        }

        //Returns the order in chich Nodes must be spawned
        public Queue OrderQueueu(List<Vector2> coords)
        {
            Queue orderCords = new Queue(); // Queue containing the order of coordinates which is to be returned
            Queue nonDiagonalCoords = new Queue();  // Queue containing the non diagonal coordinates
            Vector2 centerNodeCord = new Vector2(childNodes.GetLength(0) / 2, childNodes.GetLength(1) / 2);

            foreach (Vector2 coord in coords)
            {
                Vector2 difference = coord - centerNodeCord;    //distance in array coordinates

                if (difference.x != 0 && difference.y != 0)
                {
                    nonDiagonalCoords.Enqueue(coord);
                }
                else
                    orderCords.Enqueue(coord);
            }

            foreach (Vector2 vertCord in nonDiagonalCoords)
            {
                orderCords.Enqueue(vertCord);
            }

            return orderCords;
        }

        public void GenerateNodes(Queue coords, Node.Type type, Vector3 parenScale)
        {
            foreach (Vector2 coord in coords)
            {
                Node randomNode = childNodes[(int)coord.x, (int)coord.y];
                Vector2 dir = centerNodeCord - coord;

                //Define Z and X Naibor
                Node naiborZ = childNodes[(int)(coord.x), (int)(coord.y + dir.y)];
                Node naiborX = childNodes[(int)(coord.x + dir.x), (int)(coord.y)];
                Node naiborXZ = childNodes[(int)(coord.x + dir.x), (int)(coord.y + dir.y)];

                //Spawn Object
                Assets.SpawnRandomObject(type, ref randomNode);

                //Define the scale of the object to be spawned depending on the selected model
                Vector3 randomNodeSize = new Vector3(randomNode.gameObject.GetComponent<Renderer>().bounds.size.x, randomNode.gameObject.GetComponent<Renderer>().bounds.size.y
                    , randomNode.gameObject.GetComponent<Renderer>().bounds.size.z);

                //Define the scale for each naibor Node depending the corresponding GameObject scale
                Vector3 naiborZScale = new Vector3(naiborZ.gameObject.GetComponent<Renderer>().bounds.size.x, 0, naiborZ.gameObject.GetComponent<Renderer>().bounds.size.z);
                Vector3 naiborXScale = new Vector3(naiborX.gameObject.GetComponent<Renderer>().bounds.size.x, 0, naiborX.gameObject.GetComponent<Renderer>().bounds.size.z);
                Vector3 naiborXZScale = new Vector3(naiborXZ.gameObject.GetComponent<Renderer>().bounds.size.x, 0, naiborXZ.gameObject.GetComponent<Renderer>().bounds.size.z);

                //Set Node position depending on the type parameter
                if (type != Node.Type.GROUND)
                {
                    // Eliminate scale effect on the y Axxis
                    randomNode.transform.position = transform.position - new Vector3(0, GetComponent<MeshRenderer>().bounds.size.y / 2, 0);
                    randomNode.transform.position += new Vector3(0, randomNodeSize.y / 2, 0);
                }
                else
                    randomNode.transform.position = new Vector3(transform.position.x, parenScale.y, transform.position.z);

                if (naiborZ.type == type)
                {
                    randomNode.transform.position += new Vector3(0, 0, dir.y * 1.5f * (randomNodeSize.z / 2 + naiborZScale.z / 2));
                }
                else
                {
                    randomNode.transform.position += new Vector3(dir.x * 1.5f * (randomNodeSize.x / 2 + naiborXZScale.x / 2), 0, 0);
                }
                if (naiborX.type == type)
                {
                    randomNode.transform.position += new Vector3(dir.x * 1.5f * (randomNodeSize.x / 2 + naiborZScale.x / 2), 0, 0);
                }
                else
                {
                    randomNode.transform.position += new Vector3(0, 0, dir.y * 1.5f * (randomNodeSize.z / 2 + naiborXZScale.z / 2));
                }

                randomNode.RotateToPoint(GetComponent<Node>().rotationPoint);

                //randomNode.transform.rotation = Quaternion.Euler(GetComponent<Node>().rotationPoint - transform.forward);
                randomNode.SetType(type);
            }
        }

        // Used to set naibors to parent node
        public void SetNaibors()
        {
            for (int x = 0; x < childNodes.GetLength(0); x++)
            {
                for (int y = 0; y < childNodes.GetLength(1); y++)
                {
                    childNodes[x, y].SetNaibors(childNodes, x, y, childNodes.GetLength(0), childNodes.GetLength(1));
                }
            }
        }
    }
}